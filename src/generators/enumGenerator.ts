import { SchemaLock, Property } from '../types';
import { normalizeEnumArray } from '../utils/typeMapper';

export interface EnumInfo {
  objectName: string;
  propertyName: string;
  values: Array<{ value: string; label: string }>;
}

export function extractEnums(schema: SchemaLock): EnumInfo[] {
  const enums: EnumInfo[] = [];

  for (const [objectName, object] of Object.entries(schema)) {
    for (const [propertyName, property] of Object.entries(object.properties)) {
      if (property.type === 'Enum' && property.enum) {
        const values = normalizeEnumArray(property.enum);
        if (values.length > 0) {
          enums.push({
            objectName,
            propertyName,
            values,
          });
        }
      }
    }
  }

  return enums;
}

function toPascalCase(str: string): string {
  // Preserve case for already uppercase words like "ApplicationForm"
  // Just capitalize first letter of each underscore-separated part
  return str
    .split('_')
    .map(word => {
      // If word is already mixed case (e.g. "ApplicationForm"), keep it
      if (word !== word.toUpperCase() && word !== word.toLowerCase()) {
        return word;
      }
      // Otherwise capitalize first letter
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join('');
}

export function generateEnumsFile(enums: EnumInfo[]): string {
  const lines: string[] = [];

  lines.push('// Auto-generated by @omnifyjp/omnify');
  lines.push('// Do not edit this file manually');
  lines.push('');

  // Group by property name
  const enumsByProperty = new Map<string, EnumInfo[]>();
  for (const enumInfo of enums) {
    const key = enumInfo.propertyName;
    if (!enumsByProperty.has(key)) {
      enumsByProperty.set(key, []);
    }
    enumsByProperty.get(key)!.push(enumInfo);
  }

  // SECTION 1: Generate TypeScript types
  lines.push('// ============================================');
  lines.push('// Enum Types');
  lines.push('// ============================================');
  lines.push('');

  const enumTypeNames = new Set<string>();
  for (const enumInfo of enums) {
    const enumTypeName = `${toPascalCase(enumInfo.objectName)}${toPascalCase(enumInfo.propertyName)}`;

    if (enumTypeNames.has(enumTypeName)) {
      continue;
    }
    enumTypeNames.add(enumTypeName);

    lines.push(`export type ${enumTypeName} =`);
    const values = enumInfo.values.map(v => `  | '${v.value}'`);
    lines.push(values.join('\n') + ';');
    lines.push('');
  }

  // SECTION 2: Generate value-label mappings
  lines.push('// ============================================');
  lines.push('// Enum Options (Value -> Label mappings)');
  lines.push('// ============================================');
  lines.push('');

  for (const [propertyName, enumInfos] of enumsByProperty.entries()) {
    const values = enumInfos[0].values;
    const optionName = `${propertyName}Options`;

    lines.push(`export const ${optionName} = {`);
    for (const { value, label } of values) {
      lines.push(`  ${value}: '${label}',`);
    }
    lines.push('} as const;');
    lines.push('');
  }

  return lines.join('\n');
}

// Deprecated: Use generateEnumsFile instead
export function generateEnumOptionsFile(enums: EnumInfo[]): string {
  return ''; // No longer needed, merged into generateEnumsFile
}

