import { OmnifyObject, Property, SchemaLock } from '../types';
import { mapOmnifyTypeToTypeScript } from '../utils/typeMapper';

function toPascalCase(str: string): string {
  // Preserve case for already uppercase words like "ApplicationForm"
  // Just capitalize first letter of each underscore-separated part
  return str
    .split('_')
    .map(word => {
      // If word is already mixed case (e.g. "ApplicationForm"), keep it
      if (word !== word.toUpperCase() && word !== word.toLowerCase()) {
        return word;
      }
      // Otherwise capitalize first letter
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join('');
}

function expandCompositeFields(prop: any): any[] {
  if (!prop.fields) return [];

  const fields: any[] = [];

  for (const [fieldName, field] of Object.entries(prop.fields as Record<string, any>)) {
    const tsType = mapOmnifyTypeToTypeScript(field.type, field.nullable);
    const optional = field.nullable ? '?' : '';
    const comment = field.displayName ? ` // ${field.displayName}` : '';

    fields.push({
      name: field.propertyName,
      type: tsType,
      optional,
      comment,
    });
  }

  return fields;
}

export function generateModelFile(objectName: string, object: OmnifyObject): string {
  const lines: string[] = [];

  lines.push('// Auto-generated by @omnifyjp/omnify');
  lines.push('// Do not edit this file manually');
  lines.push('');

  // Generate interface
  lines.push(`export interface ${objectName} {`);

  for (const [propName, prop] of Object.entries(object.properties)) {
    // Skip relations for now (they're complex)
    if (prop.type === 'Association' || prop.type === 'Polymorphic') {
      continue;
    }

    // Handle composite types - expand fields
    if (prop.fields) {
      const expandedFields = expandCompositeFields(prop);
      for (const field of expandedFields) {
        lines.push(`  ${field.name}${field.optional}: ${field.type};${field.comment}`);
      }
      continue;
    }

    let propType: string;

    if (prop.type === 'Enum' && prop.enum) {
      propType = `${toPascalCase(objectName)}${toPascalCase(propName)}`;
    } else {
      propType = mapOmnifyTypeToTypeScript(prop.type, prop.nullable);
    }

    const optional = prop.nullable ? '?' : '';
    const comment = prop.displayName ? ` // ${prop.displayName}` : '';

    lines.push(`  ${propName}${optional}: ${propType};${comment}`);
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

export function generateAllModels(schema: SchemaLock): string {
  const lines: string[] = [];

  lines.push('// Auto-generated by @omnifyjp/omnify');
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push('import * as Enums from \'./enums\';');
  lines.push('');

  // Generate models
  for (const [objectName, object] of Object.entries(schema)) {
    lines.push(`// ${object.displayName}`);
    lines.push(`export interface ${objectName} {`);

    // Track processed properties to avoid duplicates from composite fields
    const processedProps = new Set<string>();

    // PHASE 1: Add foreign keys for ManyToOne associations first
    for (const [propName, prop] of Object.entries(object.properties)) {
      if (prop.type === 'Association' && prop.relation === 'ManyToOne') {
        const foreignKeyName = prop.foreignKey || `${propName}_id`;
        if (!processedProps.has(foreignKeyName)) {
          const comment = ` // Foreign key for ${prop.displayName || propName}`;
          lines.push(`  ${foreignKeyName}?: number | null;${comment}`);
          processedProps.add(foreignKeyName);
        }
      }
    }

    // PHASE 2: Add all other properties
    for (const [propName, prop] of Object.entries(object.properties)) {
      // Skip if already processed
      if (processedProps.has(propName)) {
        continue;
      }

      // Handle Association types
      if (prop.type === 'Association') {
        const comment = prop.displayName ? ` // ${prop.displayName}` : '';

        switch (prop.relation) {
          case 'ManyToOne':
            lines.push(`  ${propName}?: ${prop.target} | null;${comment}`);
            break;
          case 'OneToOne':
            lines.push(`  ${propName}?: ${prop.target} | null;${comment}`);
            break;
          case 'OneToMany':
          case 'ManyToMany':
            lines.push(`  ${propName}?: ${prop.target}[];${comment}`);
            break;
        }
        processedProps.add(propName);
        continue;
      }

      // Skip Polymorphic for now (too complex)
      if (prop.type === 'Polymorphic') {
        continue;
      }

      // Handle composite types - expand fields and mark them as processed
      if (prop.fields) {
        const expandedFields = expandCompositeFields(prop);
        for (const field of expandedFields) {
          if (!processedProps.has(field.name)) {
            lines.push(`  ${field.name}${field.optional}: ${field.type};${field.comment}`);
            processedProps.add(field.name);
          }
        }
        continue;
      }

      let propType: string;

      if (prop.type === 'Enum' && prop.enum) {
        propType = `Enums.${toPascalCase(objectName)}${toPascalCase(propName)}`;
      } else {
        propType = mapOmnifyTypeToTypeScript(prop.type, prop.nullable);
      }

      const optional = prop.nullable ? '?' : '';
      const comment = prop.displayName ? ` // ${prop.displayName}` : '';

      lines.push(`  ${propName}${optional}: ${propType};${comment}`);
      processedProps.add(propName);
    }

    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}

